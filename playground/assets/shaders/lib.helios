[[includes]]
name = "ContextData"
type = "uniform"
body = """
layout (std140, binding = 0) uniform ContextData {
    mat4 projView;
    mat4 matProj;
    mat4 matView;
    vec3 viewPosition;
    float time;
    float dt;
};
"""

[[includes]]
name = "LightingContext"
type = "uniform"
body = """
struct Light {
    vec4 position;
    vec4 color;

    float linear;
    float quadratic;
    
    uint mode;
    uint padding;
};
const uint DIRECTIONAL_LIGHT = 0;
const uint POINT_LIGHT = 1;
const int MAX_LIGHTS = 128;
const int MAX_LIGHT_CASTERS = 4;
layout (std140, binding = 1) uniform LightingContext {
    Light lights[MAX_LIGHTS];
    uvec4 shadowCasters[MAX_LIGHT_CASTERS];                      // IDs of the lights used for shadow mapping
    mat4 matLightSpaces[MAX_LIGHT_CASTERS];  // Space matrices of the lights used for shadow mapping
    vec4 ambient;                             // .rgb for the color and .a for the intensity
    uint lightCount;
    uint shadowCasterCount;
    vec2 shadowMapSize;
};

uniform sampler2D mapShadow;

float sampleShadowMap (int casterIndex, vec2 texCoord) {
    vec2 tileSize = vec2(
        shadowMapSize.x / 2,
        shadowMapSize.y / float(MAX_LIGHT_CASTERS));
    vec2 tileCoord = vec2(
        tileSize.x,
        tileSize.y * float(casterIndex));

    vec2 pixelCoord = vec2(
        tileCoord.x + (tileSize.x * texCoord.x), 
        tileCoord.y + (tileSize.y * texCoord.y));
    vec2 absUVCoord = vec2(
        pixelCoord.x / shadowMapSize.x,
        pixelCoord.y / shadowMapSize.y);

    bvec2 inBoundsMin = greaterThanEqual(pixelCoord, tileCoord); 
    bvec2 inBoundsMax = lessThanEqual(pixelCoord, tileCoord + tileSize);
    float result = all(inBoundsMin) && all(inBoundsMax) ? texture(mapShadow, absUVCoord).r : 1.0;
    return result;
}

float computeShadowValue(int casterIndex, vec3 position, vec3 normal) {
    uint lightID = shadowCasters[casterIndex].x;
    Light light = lights[lightID];
    vec3 lightDir = normalize(light.position.xyz);
    vec4 lightSpacePosition = matLightSpaces[lightID] * vec4(position, 1.0);
    float bias = 0.05 * (1.0 - dot(normal, lightDir));
	bias = max(bias, 0.005);

    vec3 projCoord = lightSpacePosition.xyz / lightSpacePosition.w;
    if (projCoord.z > 1.0) {
        return 0.0;
    }
    projCoord = projCoord * 0.5 + 0.5;
    float currentDepth = projCoord.z;


    vec2 tileSize = vec2(
        shadowMapSize.x / 2,
        shadowMapSize.x / float(MAX_LIGHT_CASTERS));
    float result = 0.0;
    vec2 texelSize = 1.0 / tileSize;
    for (int x = -1; x <= 1; x += 1) {
        for (int y = -1; y <= 1; y += 1) {
            vec2 pcfCoord = projCoord.xy + vec2(x, y) * texelSize;
            float pcfDepth = sampleShadowMap(casterIndex, pcfCoord);
            result += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    result /= 9.0;
    return result;
}
"""

[[includes]]
name = "applyAtmosphericFog"
type = "procedure"
decl = "vec3 applyAtmosphericFog(in vec3 texelClr, float dist, vec3 viewDir, vec3 lightDir);"
body = """
vec3 applyAtmosphericFog(in vec3 texelClr, float dist, vec3 viewDir, vec3 lightDir) {
    const vec3 fogClr = vec3(0.5, 0.6, 0.7);
    const float fogDistNear = 50.0;
    const float fogDistFarBlend = 30.0;
    const float fogDensity = 0.005;
    const float fogNearDensity = 5.0;

    float fogNearContribution = max((1.0 - pow((dist / fogDistNear), fogNearDensity)), 0.0);
    float fogFarContribution = (exp(-dist * fogDensity));
    float fogContribution = dist < fogDistFarBlend ? fogNearContribution : min(fogNearContribution, fogFarContribution);
    fogContribution = 1 - fogContribution;
    
    vec3 result = mix(texelClr, fogClr, fogContribution);
    return result;
}
"""

[[includes]]
name = "linearDepthValue"
type = "procedure"
decl = "float linearDepthValue(float near, float far, float depth);"
body = """
float linearDepthValue(float near, float far, float depth) {
    float result = 2.0 * near * far / (far + near - (2.0 * depth - 1.0) * (far - near));
    return result;
}
"""

[[shaders]]
name = "deferred_geometry"

[shaders.vertex]
template = false
includes = ["ContextData"]
include_line = 17
source ="""
#version 450 core
layout (location = 0) in vec3 attribPosition;
layout (location = 1) in vec3 attribNormal;
layout (location = 2) in vec4 attribTangent;
layout (location = 3) in vec4 attribJoints;
layout (location = 4) in vec4 attribWeights;
layout (location = 5) in vec2 attribTexCoord;
layout (location = 7) in mat4 attribInstanceMat;

out VS_OUT {
	vec3 position;
	vec3 normal;
	vec2 texCoord;
	mat3 matTBN;
} frag;

// builtin uniforms
uniform mat4 mvp;
uniform mat4 matModel;
uniform mat4 matModelLocal;
uniform mat3 matNormal;
uniform mat3 matNormalLocal;
uniform mat4 matJoints[19];

uniform bool useTangentSpace;
uniform bool useJointSpace;
uniform bool instanced = false;

void main()
{
	mat4 finalMVP = mat4(1);
	mat4 finalMatModel = mat4(1);
	mat3 finalMatNormal = mat3(1);

    if (instanced) {
        finalMatModel = attribInstanceMat;
    }

	if (useJointSpace) {
		mat4 matSkin = 
		attribWeights.x * matJoints[int(attribJoints.x)] +
		attribWeights.y * matJoints[int(attribJoints.y)] +
		attribWeights.z * matJoints[int(attribJoints.z)] +
		attribWeights.w * matJoints[int(attribJoints.w)];

		finalMatModel = finalMatModel * matModelLocal * matSkin;
		finalMatNormal = matNormalLocal * mat3(matSkin);
		finalMVP = projView * finalMatModel;
	} else {
		finalMatModel = finalMatModel * matModel;
		finalMatNormal = matNormal;
		finalMVP = projView * finalMatModel;
	}

	frag.position = vec3(finalMatModel * vec4(attribPosition, 1.0));
	frag.normal = finalMatNormal * attribNormal;
	frag.texCoord = attribTexCoord;

	if (useTangentSpace) {
		vec3 t = normalize(finalMatNormal * vec3(attribTangent));
		vec3 n = normalize(finalMatNormal * attribNormal);
		t =  normalize(t - dot(t, n) * n);
		vec3 b = cross(n, t);

		frag.matTBN = inverse(transpose(mat3(t, b, n)));
	}

    gl_Position = finalMVP * vec4(attribPosition, 1.0);
}
"""

[shaders.fragment]
template = true
source = """
#version 450 core
layout (location = 0) out vec4 bufferedPosition;
layout (location = 1) out vec4 bufferedNormal;
layout (location = 2) out vec4 bufferedAlbedo;

in VS_OUT {
	vec3 position;
	vec3 normal;
	vec2 texCoord;
	mat3 matTBN;
} frag;

uniform sampler2D mapDiffuse0;
uniform sampler2D mapNormal0;
uniform bool useTangentSpace;

vec3 sampleAlbedo();

void main() {
	if (useTangentSpace) {
		vec3 sampledNormal = texture(mapNormal0, frag.texCoord).rgb;
		sampledNormal = sampledNormal * 2.0 - 1.0;
		sampledNormal = normalize(frag.matTBN * sampledNormal);

		bufferedNormal = vec4(sampledNormal, 1.0);
	} else {
		bufferedNormal = vec4(normalize(frag.normal), 1.0);
	}

	bufferedPosition = vec4(frag.position, 1.0);
	bufferedAlbedo.rgb = sampleAlbedo();
	bufferedAlbedo.a = 1.0;
}
"""

[[shaders.fragment.extensions]]
name = "default"
source = """
vec3 sampleAlbedo() {
    vec3 result = texture(mapDiffuse0, frag.texCoord).rgb;
    return result;
}
"""

[[shaders.fragment.extensions]]
name = "terrain"
source = """
const float heightTreshold = 3;
const float tileCount = 2;
const float tileSize = 0.5;
vec3 sampleAlbedo() {
    float baseOffset = clamp(floor(frag.position.y / heightTreshold), 0.0, tileCount - 1.0);
    vec2 baseCoord = vec2(frag.texCoord.x + (baseOffset * tileSize), frag.texCoord.y);
    vec3 result = texture(mapDiffuse0, baseCoord).rgb;

    float blendValue = fract(frag.position.y / heightTreshold);
    if (blendValue > 0.0) {
        float blendOffset = clamp(ceil(frag.position.y / heightTreshold), 0.0, tileCount - 1.0);
        vec2 blendCoord = vec2(frag.texCoord.x + (blendOffset * tileSize), frag.texCoord.y);
        vec3 blendClr = texture(mapDiffuse0, blendCoord).rgb;
        result = (result * (1 - blendValue)) + (blendClr * blendValue);
    }
    return result;
}
"""

[[shaders]]
name = "deferred_shading"

[shaders.vertex]
template = false
source = """
#version 450 core
layout (location = 0) in vec2 attribPosition;
layout (location = 5) in vec2 attribTexCoord;

out VS_OUT {
	vec2 texCoord;
} frag;

void main() {
	frag.texCoord = attribTexCoord;

	gl_Position = vec4(attribPosition, 0.0, 1.0);
}
"""

[shaders.fragment]
template = false
includes = ["ContextData", "LightingContext", "applyAtmosphericFog"]
include_line = 8
source = """
#version 450 core

in VS_OUT {
    vec2 texCoord;
} frag;

out vec4 finalColor;

uniform sampler2D bufferedPosition;
uniform sampler2D bufferedNormal;
uniform sampler2D bufferedAlbedo;
uniform sampler2D bufferedDepth;

vec3 computeDirectionalLighting( Light light, vec3 p, vec3 n );
vec3 computePointLighting( Light light, vec3 p, vec3 n );

void main() {
    vec4 p = texture(bufferedPosition, frag.texCoord).rgba;
    vec3 position = p.rgb;
    vec3 normal = texture(bufferedNormal, frag.texCoord).rgb;
    vec3 albedo = texture(bufferedAlbedo, frag.texCoord).rgb;
    float distance = length(position - viewPosition);

    if (p.a <= 0.05) {
        discard;
    }

    vec3 ambient = ambient.xyz * ambient.a;

    float shadowValue = 0.0;
    for (int i = 0; i < shadowCasterCount; i += 1) {
        shadowValue += computeShadowValue(i, position, normal);
    }
    //shadowValue = clamp(shadowValue, 0.0, 1.0);

    vec3 lightValue = vec3(0);
    for (int i = 0; i < lightCount; i += 1) {
        Light light = lights[i];

        if (light.mode == DIRECTIONAL_LIGHT) {
            lightValue += computeDirectionalLighting(light, position, normal);
        } else if (light.mode == POINT_LIGHT) {
            lightValue += computePointLighting(light, position, normal);
        }
    }

    vec3 result = (ambient + ((1.0 - shadowValue) * lightValue)) * albedo; 
    result = applyAtmosphericFog(result, distance, vec3(0), vec3(0));
    finalColor = vec4(result, 1.0);
}

vec3 computeDirectionalLighting( Light light, vec3 p, vec3 n ) {
    vec3 lightDir = normalize(light.position.xyz);
    float diffuseContribution = max(dot(lightDir, n), 0.0);
    vec3 diffuse = diffuseContribution * light.color.rgb;

    vec3 viewDir = normalize(viewPosition - p);
    vec3 reflectDir = reflect(-lightDir, n);
    float specContribution = max(dot(viewDir, reflectDir), 0.0);
    specContribution = pow(specContribution, 32.0);
    vec3 specular =  (specContribution * light.color.rgb);

    return (diffuse + specular);
}

vec3 computePointLighting( Light light, vec3 p, vec3 n ) {
    vec3 lightDir = normalize(light.position.xyz - p);
    float diffuseContribution = max(dot(lightDir, n), 0.0);
    vec3 diffuse = diffuseContribution * light.color.rgb;

    vec3 viewDir = normalize(viewPosition - p);
    vec3 reflectDir = reflect(-lightDir, n);
    float specContribution = max(dot(viewDir, reflectDir), 0.0);
    vec3 specular = 0.5 * (specContribution * light.color.rgb);

    float distance = length(light.position.xyz - p);
    float attenuation = 1.0 / (1.0 + light.linear * distance + light.quadratic * (pow(distance, 2)));
    return (diffuse * attenuation) + (specular * attenuation);
}
"""

[[shaders]]
name = "forward_geometry"

[shaders.vertex]
template = false
includes = ["ContextData", "LightingContext"]
include_line = 15
source = """
#version 450 core
layout (location = 0) in vec3 attribPosition;
layout (location = 1) in vec3 attribNormal;
layout (location = 2) in vec4 attribTangent;
layout (location = 5) in vec2 attribTexCoord;
layout (location = 7) in mat4 attribInstanceMat;

out VS_OUT {
    vec3 position;
    vec3 normal;
    vec2 texCoord;
    mat3 matTBN;
} frag;


uniform mat4 mvp;
uniform mat4 matModel;
uniform mat3 matNormal;

uniform bool useTangentSpace;
uniform bool instanced;

void main() {
    mat4 finalModelMat = mat4(1);
    if (instanced) {
        finalModelMat = attribInstanceMat * matModel;    
    } else {
        finalModelMat = matModel;
    }

    if (useTangentSpace) {
        vec3 t = normalize(matNormal * vec3(attribTangent));
	    vec3 n = normalize(matNormal * attribNormal);
	    t =  normalize(t - dot(t, n) * n);
	    vec3 b = cross(n, t);

	    frag.matTBN = transpose(mat3(t, b, n));
    }

    frag.position = vec3(finalModelMat * vec4(attribPosition, 1.0));
    frag.texCoord = attribTexCoord;
    frag.normal = matNormal * attribNormal;

    gl_Position = projView * finalModelMat * vec4(attribPosition, 1.0);
}
"""

[shaders.fragment]
template = false
includes = ["ContextData", "LightingContext", "applyAtmosphericFog"]
include_line = 9
source = """
#version 450 core
in VS_OUT {
    vec3 position;
    vec3 normal;
    vec2 texCoord;
    mat3 matTBN;
} frag;


out vec4 finalColor;

uniform sampler2D diffuse0;
uniform sampler2D normal0;

vec3 computeDirectionalLighting( Light light, vec3 p, vec3 n );
vec3 computePointLighting( Light light, vec3 p, vec3 n );

void main() {
    vec3 position = frag.position;
    vec3 normal = frag.normal;
    vec4 a = texture(diffuse0, frag.texCoord);
    vec3 albedo = a.rgb;
    float distance = length(position - viewPosition);

    if (a.a < 0.25) {
        discard;
    }

    vec3 ambient = ambient.xyz * ambient.a;

    //float shadowValue = 0.0;
    //for (int i = 0; i < shadowCasterCount; i += 1) {
    //    shadowValue += computeShadowValue(i, position, normal);
    //}
    //shadowValue = clamp(shadowValue, 0.0, 1.0);

    vec3 lightValue = vec3(0);
    for (int i = 0; i < lightCount; i += 1) {
        Light light = lights[i];

        if (light.mode == DIRECTIONAL_LIGHT) {
            lightValue += computeDirectionalLighting(light, position, normal);
        } else if (light.mode == POINT_LIGHT) {
            lightValue += computePointLighting(light, position, normal);
        }
    }

    vec3 result = (ambient + (lightValue)) * albedo; //(1.0 - shadowValue) * 
    result = applyAtmosphericFog(result, distance, vec3(0), vec3(0));
    finalColor = vec4(result, a.a);
}

vec3 computeDirectionalLighting( Light light, vec3 p, vec3 n ) {
    vec3 lightDir = normalize(light.position.xyz);
    float diffuseContribution = max(dot(lightDir, n), 0.0);
    vec3 diffuse = diffuseContribution * light.color.rgb;

    vec3 viewDir = normalize(viewPosition - p);
    vec3 reflectDir = reflect(-lightDir, n);
    float specContribution = max(dot(viewDir, reflectDir), 0.0);
    specContribution = pow(specContribution, 32.0);
    vec3 specular =  (specContribution * light.color.rgb);

    return (diffuse + specular);
}

vec3 computePointLighting( Light light, vec3 p, vec3 n ) {
    vec3 lightDir = normalize(light.position.xyz - p);
    float diffuseContribution = max(dot(lightDir, n), 0.0);
    vec3 diffuse = diffuseContribution * light.color.rgb;

    vec3 viewDir = normalize(viewPosition - p);
    vec3 reflectDir = reflect(-lightDir, n);
    float specContribution = max(dot(viewDir, reflectDir), 0.0);
    vec3 specular = 0.5 * (specContribution * light.color.rgb);

    float distance = length(light.position.xyz - p);
    float attenuation = 1.0 / (1.0 + light.linear * distance + light.quadratic * (pow(distance, 2)));
    return (diffuse * attenuation) + (specular * attenuation);
}
"""

[[shaders]]
name = "forward_water"

[shaders.vertex]
template = false
includes = ["ContextData", "LightingContext"]
include_line = 22
source = """
#version 450 core
layout (location = 0) in vec3 attribPosition;
layout (location = 1) in vec3 attribNormal;
layout (location = 2) in vec3 attribTangent;
layout (location = 5) in vec2 attribTexCoord;

out VS_OUT {
	vec3 position;
	vec3 normal;
	vec2 texCoord;
	vec3 tanLightPosition;
	vec3 tanViewPosition;
	vec3 tanPosition;
	vec4 lightSpacePosition;
	vec4 clipSpacePosition;
} frag;

uniform mat4 mvp;
uniform mat4 matModel;
uniform mat3 matNormal;

void main()
{
	frag.position = vec3(matModel * vec4(attribPosition, 1.0));
	frag.clipSpacePosition = projView * matModel * vec4(attribPosition, 1.0);
	frag.normal = matNormal * attribNormal;
	frag.texCoord = attribTexCoord;
	frag.lightSpacePosition = matLightSpaces[0] * matModel * vec4(attribPosition, 1.0);

	vec3 t = normalize(matNormal * vec3(attribTangent));
	vec3 n = normalize(matNormal * attribNormal);
	t =  normalize(t - dot(t, n) * n);
	vec3 b = cross(n, t);

	mat3 tbn = transpose(mat3(t, b, n));
	frag.tanLightPosition = tbn * lights[0].position.xyz;
	frag.tanViewPosition = tbn * viewPosition;
	frag.tanPosition = tbn * frag.position;

    gl_Position = mvp*vec4(attribPosition, 1.0);
} 
"""

[shaders.fragment]
template = false
includes = ["ContextData", "LightingContext", "linearDepthValue", "applyAtmosphericFog"]
include_line = 17
source = """
#version 450 core
in VS_OUT {
	vec3 position;
	vec3 normal;
	vec2 texCoord;
	vec3 tanLightPosition;
	vec3 tanViewPosition;
	vec3 tanPosition;
	vec4 lightSpacePosition;
	vec4 clipSpacePosition;
} frag;

out vec4 finalColor;

uniform sampler2D texture0;
uniform sampler2D texture1;
uniform sampler2D mapViewDepth;

vec2 fade(vec2 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

vec4 rand4(vec4 p) { return mod(((p * 34.0) + 1.0) * p, 289.0); }

float perlin(vec2 P) {
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;
  vec4 i = rand4(rand4(ix) + iy);
  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
  vec4 gy = abs(gx) - 0.5;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;
  vec2 g00 = vec2(gx.x, gy.x);
  vec2 g10 = vec2(gx.y, gy.y);
  vec2 g01 = vec2(gx.z, gy.z);
  vec2 g11 = vec2(gx.w, gy.w);
  vec4 norm =
      1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01),
                                                 dot(g10, g10), dot(g11, g11));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;
  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));
  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

void main()
{
	const float near = 0.1;
	const float far = 100;
	const float normalScrollSpeed = 0.01;

	const vec3 shallowWaterClr = vec3(0.325, 0.658, 0.84);
	const vec3 deepWaterClr = vec3(0.07, 0.325, 0.71);
	const float transparentMaxDepth = 1.0;
	const float minTransparency = 0.65;
	const float foamTransparency = 0.25;


    float distance = length(frag.position - viewPosition);
	float scrollValue = time * normalScrollSpeed;
	vec3 tanNormal = texture(texture1, frag.texCoord + vec2(scrollValue)).rgb;
	tanNormal = normalize(tanNormal * 2.0 - 1.0);
	vec3 tanLightDir = normalize(frag.tanLightPosition);
	float diffuseValue = max(dot(tanLightDir, tanNormal), 0.0);
	vec3 diffuse = lights[0].color.rgb;

	vec3 ambient = ambient.xyz * ambient.a;

	vec3 viewDir = normalize(frag.tanViewPosition - frag.tanPosition);
	vec3 reflectDir = reflect(-tanLightDir, tanNormal);
	float specValue = max(dot(viewDir, reflectDir), 0.0);
	specValue = pow(specValue, 32);
	vec3 specular = (specValue * lights[0].color.rgb);
	vec3 specular2 = smoothstep(0.6, 0.8, specular);

	vec3 depthCoord  = frag.clipSpacePosition.xyz / frag.clipSpacePosition.w;
	depthCoord = (depthCoord * 0.5) + 0.5;
	float result = texture(mapViewDepth, depthCoord.xy).r;
	float linearDepth = linearDepthValue(near, far, result);

	float viewWaterDepth = linearDepthValue(near, far, gl_FragCoord.z);
	float waterDepth = (linearDepth - viewWaterDepth) * 25;

	const float cutoffMin = 0.5; 
	const float cutoffMax = 1.5;
	const float cutoffRange = 0.1;
	float noise = perlin(vec2(frag.clipSpacePosition.x * time, frag.clipSpacePosition.z * time)) * cutoffRange;
	waterDepth = smoothstep(cutoffMin + noise, cutoffMax + noise, waterDepth);

	float normWaterDepth = min((linearDepth - viewWaterDepth) / transparentMaxDepth, 1.0);
	float waterTransparency = max(foamTransparency - waterDepth, normWaterDepth);
	waterTransparency = smoothstep(0.05, 0.7, waterTransparency) + minTransparency;

	vec3 waterClr = mix(shallowWaterClr, deepWaterClr, min((linearDepth - viewWaterDepth) / 2.0, 1.0));
	vec3 depthClr = waterClr * waterDepth + vec3(1.0) * (1.0 - waterDepth);
	// depthClr.r = clamp(depthClr.r, waterClr.r, 1.0);
	// depthClr.g = clamp(depthClr.g, waterClr.g, 1.0);
	// depthClr.b = clamp(depthClr.b, waterClr.b, 1.0);

	// vec3 resultClr = (1.0 + specular2) * depthClr + smoothstep(0.85, 0.95, specular);
    vec3 resultClr = (ambient + diffuse + specular) * depthClr;
    resultClr = applyAtmosphericFog(resultClr, distance, vec3(0), vec3(0));
	finalColor = vec4(resultClr, waterTransparency);
}
"""